---
title: 《大话设计模式》读书整理
copyright: true
date: 2018-08-21 22:48:38
categories: 设计模式
tags:
    - 大话设计模式
---

# 面向对象设计原则
如何同时提高一个软件系统的**可维护性和可复用性**是面向对象设计需要解决的核心问题之一。
面向对象设计原则为支持可维护性及复用而诞生，常见的7种面向对象设计原则如下表所示，所有的设计模式都遵循一个或多个面向对象的设计原则。

| 设计原则名称 | 定义 |
|--- |--- |
| 单一职责原则（Single Responsibility Principle,SRP） |一个类只负责一个功能领域中的相应职责 |
| 开闭原则（Open-Closed Principle,OCR）|软件实体应对扩展开放，而对修改关闭|
| 里氏代换原则（Liskov Substitution Principle, LSP）| 所有引用基类对象的地方能够透明地使用其子类的对象 |
| 依赖倒转原则（Dependence Inversion Principle，DIP）| 抽象不应该依赖于细节，细节应该依赖于抽象，也就是说，要针对接口编程，而不是针对实现编程 |
| 接口隔离原则（Interface Segregation Principle, ISP）|使用多个专门的接口，而不使用单一的总接口 |
| 合成复用原则（Composite Reuse Principle, CRP）|尽量使用对象的组合，而不是继承来达到复用的目的 |
| 迪米特法则（Law of Demeter, LoD）|一个软件实体应当尽可能少地与其他实体发生作用 |

<!--more-->

# 1.简单工厂模式(Simple Factory)
面向对象的分析设计的编程思想，通过封装、继承、多态将程序的耦合度降低，使用设计模式使得程序更加的灵活，容易修改，并且易于复用。
> 使用单独的类来做这个创造实例的过程，这就是工厂，定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。
> 因为在简单工厂模式中用于创建实例的方法使静态(Static)方法，因此简单工厂模式又被称为静态工厂方法模式。
> 编程是一门技术，更加是一门艺术！

简单工厂模式的要点在于：**当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。**
**主要优点：**
- 工厂类中包含必要的判断逻辑，可以决定在什么时候创建一个产品类的对象，客户端可以免除直接创建产品对象的职责，也就是说实现了对象创建和使用的分离。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性

# 2.策略模式(Strategy)
>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。

策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，它可以以 **相同的方式** 调用所有的算法，减少了各种算法类与使用算法类之间的耦合。

**策略模式封装了变化**

策略模式的Strategy类层次为Context定义了一系列可供重用的算法或行为，继承有助于析取出这些算法中的公共功能。
策略模式的优点是简化了单元测试，将不同行为或者算法堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为，因此借助简单工厂模式，然后将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。
```csharp
abstract class Strategy//抽象算法类，定义所有支持的算法的公共接口
{
    public abstract void AlgorithmInterface();
}

class ConcreStrategyA: Strategy//具体算法类，封装了具体的算法或者行为，继承于Strategy
{
    public override void AlgorithmInterface()//算法A的具体实现方法
    {
        console.WriteLine("算法A的实现");
    }
}

class ConcreStrategyB: Strategy
{
    public override void AlgorithmInterface()
    {
        console.WriteLine("算法B的实现");
    }
}
class Context//用具体的ConcreStrategy来配置，维护一个对Strategy对象的引用
{
    Strategy strategy;
    public Context(Strategy strategy)//初始化时，传入具体的策略对象
    {
        this.strategy = strategy;
    }
//上下文接口，根据具体的策略对象，调用其算法方法
    public void ContextInterface()
    {
        strategy.AlgorithmInterface();
    }
}

static void Main(string[] args)
{
    Context context;
    context = new Context(new ConcreStrategyA());//实例化不同的算法策略
    context.ContextInterface();
    context = new Context(new ConcreStrategyB);
    context.ContextInterface();
    console.Read();
}
```
# 3.单一职责原则
**前言**
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他的职责的能力。而这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。
**如何判断一个类是否有多个职责？**
- 想到多于一个动机去改变一个类，那么这个类就多于一个职责，就应该发现这些职责然后将这些职责相互分离
- 易维护、易扩展、易复用、灵活多样

# 4.开放-封闭原则（OCP: Open-Closed Principle）
- Open for extension, Closed for modification(扩展开放、更改封闭)：软件实体（类、模块、函数等等）应该是可以扩展的、但是不可修改
- 多扩展，少修改
- 原则是：面对新的需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码
- 全力以赴是必须，两手准备也是灵活处事的表现

# 5.依赖倒转原则
面向对象的 **强内聚、松耦合** 的关系
- 高层模块不应该依赖低层模块，两个都应该依赖抽象（接口或者抽象类）。
- 抽象不应该依赖细节，细节应该依赖抽象。

**里式代换原则：** 子类型必须能够替换掉他们的父类型，即在一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别，也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。

# 6.装饰模式（Decorator）
动态地给一个对象添加一些额外的职责，就增加功能来讲，装饰模式比生成子类更为灵活（人穿衣服的顺序，服饰之于人是装饰）

Component -->concreteComponent, Decorator(抽象装饰器) -->在抽象装饰器有SetComponent（装饰接口）接口包装 component，因此就串起来了。

**装饰模式的优点：** 把类中的装饰功能从类中搬移去除，这样就可以简化原有的类，有效的把类的核心职责和装饰功能区分开，而且可以去除相关类中重复的装饰逻辑。

# 7.代理模式（Proxy）
为其他对象提供一种代理以控制对这个对象的访问
Subject –->RealSubject, Proxy; 也就是说两者都继承自Subject,拥有相同的接口，但具体实现中的接口是Proxy中的接口封装RealSubject中的接口，以实现代理的方式。
代理模式的应用：
- 远程代理：为一个对象在不同的地址空间提供局部代理，隐藏一个对象存在于不同地址空间的事实
- 虚拟代理：浏览器页面的预加载
- 安全代理：用来控制真实对象访问时的权限
- 智能指引：调用真实对象时，代理处理另外的一些事
简而言之：代理模式就是在访问对象时引入一定程度的间接性，而这种间接性，可以附加多种用途。

# 8.工厂方法模式（Factory Method）
是简单工厂模式的扩充，增加了工厂接口（interface IFactory）__[工厂产生实例的地方]__。

**简单工厂：**  工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。

**工厂方法：** 定义一个用于创建对象的接口，让子类决定实例化哪一个类。

工厂方法使一个类的实例化延迟至其子类，也就是将实例化的选择上浮至客户端处理。
工厂方法克服了简单工厂违背开放-封闭原则的缺点，保持了封装对象创建过程的优点。

# 9.原型模式（Prototype）
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
从一个对象再创建另外一个可定制的对象，并且不需要知道任何创建的细节。
好处是不用重新初始化对象，动态地获得对象运行时的状态。

**深拷贝和浅拷贝：**
如果字段是值类的，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象，因此，原始对象及其复本引用同一对象。

# 10.模板方法模式（TemplateMethod）
当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上实现可能不同时，我们通常考虑用模板方法模式进行处理。

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定结构。

模板方法模式是通过把不变行为搬移到父类中，去除子类中的重复代码，来体现它的优势，模板方法模式提供了一个很好的代码复用平台。

**注意：** 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现，我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复不变的行为的纠缠。

# 11.迪米特法则 – 最少知识原则
**来源：**
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。
在类的结构设计上，每一个类都应当尽量降低成员的访问权限，强调了类之间的松耦合，类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。__---信息的隐藏促进了软件的复用。__

# 12.外观模式（门面模式 Facade）
是为了减少各个程序模块之间的 **耦合性**

**定义：**
为子系统的中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

**白话解释:**
也就是将几个子系统（类）放在一个统一的外观（Facade）中，包裹一层；然后供客户端或新系统统一调用。

**使用外观模式的时机：**
1. 在设计初期阶段，有意识的将不同的两层分离，经典的三层架构：数据访问层 –》 业务逻辑层 –》表示层；层与层之间使用Facade封装。
2. 在开发阶段，增加外观Facade来提供一个简单的接口，减少他们之间的依赖。
3. 维护遗留大型系统时，为设计粗糙的遗留代码设计一个简单清晰的Facade，让新系统与Facade交互，Facade与遗留代码交互所有复杂的工作。

# 13.建造者模式（Builder，生成器模式）
这是对建造流程的抽象。人基本特点抽象化（稳定的特点），体型的胖瘦具体化;
将一个复杂对象的 **构建** 与它的 **表示** 分离，使得同样的构建过程可以创建不同的表示。
包含指挥者（Director）是用户和建造过程的隔离，指挥者实现用户的需求，而不将构造过程展示给用户:
用户 | Director | 建造过程
建造者模式是在当创建复杂对象的算法应该 **独立于** 该对象的组成部分以及它们的装配方式时的模式。

# 14.观察者模式

又叫发布 – 订阅（Publish/Subscribe）模式，定义了一种 **一对多** 的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生改变时，会通知所有观察者对象，使它们能够自动更新自己。

**使用的动机来源：** 不希望为了维护一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便，而观察者模式中的关键对象是主题 Subject 和 观察者 Observer ，一个 Subject 可以有任意数目的依赖它的 Observer，一旦 Subject 的状态发生了改变，所有的 Observer 都可以得到通知，Subject 发出通知时并不需要知道谁是它的观察者，也就是说，具体的观察者是谁，它根本不需要知道。而任何一个具体的观察者也不需要知道其他观察者的存在。
观察者模式所做的工作其实就是解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使各自的变化都不会影响到另一边的变化。

增加委托事件，观察者中的 Update 动作，进一步具体化，也就是将 Update 的函数具体为相应的动作，然后在具体的 Subject 中增加委托事件 EventHandler，而这个 EventHandler 是 Update 的引用方法（别名，或者有点像函数指针）。

# 15.抽象工厂模式（Abstract Factory）
> 菜鸟程序员碰到问题，只会用时间来摆平，编程是一门艺术，如果增加一个功能就需要大批量的改动，这就是非常丑陋的代码！
>心急讨不了好媳妇 ~

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**优点：**
- 易于交换产品系列，在一个应用中只需要在初始化的时候出现一次，这就使得改变一个应用的具体工厂变的非常容易，它只需要改变具体工厂即可使用不同的产品配置；
- 它让具体的创建实例过程与客户端分离，客户端是通过他们的抽象接口操纵实例，产品的具体类名也被具体的工厂的实现分离，不会出现在客户代码中。
使用*反射技术*去除简单工厂中的 switch --- case的判断逻辑 | --》 反射+抽象工厂模式

**总结：**
所有在用简单工厂的地方，都可以考虑用反射技术去除switch 或者 if的判断逻辑，解除分支判断带来的耦合。

# 16.状态模式（State）
**Tips：**
方法过长（Long Method）是*坏味道*，意味着这个方法承担的责任过大，这个在设计模式上是很糟糕的行为，类需要遵循单一职责原则，面向对象设计其实就是希望做到代码的责任分解。

**概念：**
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
适用的场景：当控制一个对象状态转换的条件表达式过于复杂时的情况，也就是当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。

**好处：**
将与特定状态的行为局部化，并且将不同状态的行为分割开来。状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互间的依赖

# 17.适配器模式（Adapter）
将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作（加一层封装接口来适配现在的系统使用）。

系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配。Adapter 主要应用于希望复用一些现存的类，但是接口又与复用环境不一致的情况。

* 类适配模式：需要支持类的多重继承（只有C++支持多重继承）
* 对象适配模式
在使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，应该考虑 Adapter，客户代码只需要调用这个统一的接口（Adapter）。
也就是在这种情况：*两个类所做的事情相同或相似，但是具有不同的接口时要使用它。*
**注：** 只有碰到无法改变原有设计和代码的情况时，才考虑适配。在有小的接口不统一的问题发生时，及时重构。

# 18.备忘录模式（Memento）
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。三个角色：发起人（Originator） --》 备忘录（Memento）类 –》 管理者（Caretaker）类

**适用场景：** Memento模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时，Originator 可以根据保存的 Memento信息还原到前一状态。

# 19.组合模式（Composite）
将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

**适用的场景：** 需求中是体现部分与整体层次的结构时，并且希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，考虑使用组合模式。
组合模式让客户可以一致地使用组合结构和单个对象。

# 20.迭代器模式（Iterator）
提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。
需要对聚集（数组）有多种方式遍历时，可以考虑用迭代器模式：foreach .. in

**注：** 迭代器肯定是和具体的聚集绑定在一起的，在声明具体的迭代器时必须初始化绑定具体聚集。
迭代器（Iterator）模式就是分离了集合对象的遍历行为，抽象出一个迭代器来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据

# 21.单例模式（Singleton）
>复制黏贴是最容易的编程，也是最没有价值的编程!

保证一个类仅有一个实例，并提供一个访问它的一个全局访问点。也就是让类自身负责保存它的唯一实例，并提供一个访问该实例的方法（ GetInstacne（））。

单例模式试图解决的两个**基本问题**：
- 全局访问
- 实例化控制
具体代码体现：

```csharp
class Singleton //懒汉式单例类
{
    private static Singleton instance;
    private Singleton() {}//构造方法为private，外界无法通过new来实例化
    private static readonly object syncRoot = new object();//lock 确保当一个线程位于代码临界区时，另一个线程不能进入临界区
    public static Singleton GetInstance()//获得本类实例的唯一全局访问点
    {
        if(instance == null)//先判断实例是否存在，不存在则加锁处理
        {
            lock(syncRoot)
            {
                if(instance == null) //双重锁定，保证线程安全（Double-Check Locking）
                {
                    instace = new Singleton();
                }
            }
        }
        return instance;
    }
}

public sealed class Singleton //饿汉式单例类
{
    private static readonly Singleton instance = new Singleton(); //静态初始化方式，类一加载就实例化对象，需要提前占用系统资源。
    private Singleton() {}
    public static Singleton GetInstance()
    {
        return instance;
    }
}
```

# 22. 桥接模式（Bridge）
面向对象的原则：优先使用对象的 **合成/聚合** ，而不是类继承
- 聚合：表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分
- 合成：表示一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样
优先使用对象的合成\聚合将有助于保持每个类的封装，并被集中在单个任务上。这样的类和类继承层次会保持较小规模。
> **概念：** 将抽象部分与它的实现分离，使它们可以独立的变化。实现指的是抽象类和它的派生类用来实现自己的对象。

实现系统可能有多角度分类，每一种分类都有可能发生变化，那么就把这种多角度分离出来让它们独立变化，减少它们之间的耦合。

# 23.命令模式（Command）
降低 **行为请求者** 与 **行为实现者** 的紧耦合。

> **概念：** 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作

**命令模式的作用**
- 能容易地设计一个命令队列
- 在需要的情况下，可以较容易的将命令记入日志
- 允许接收请求的一方决定是否需要否决请求
- 可以容易地实现对请求的撤销或者重做
- 加进新的具体命令类不影响其他的类，增加新的具体命令类较容易
- 把请求一个操作的对象与知道如何执行该操作的对象分隔开

# 24.职责链模式（Chain of Responsibility）
> **概念：** 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个责任对象处理它为止。

**好处：** 接收者和发送者都没有对方的明确信息，且链中的对象自己也并不知道链的结构。
结果是职责链可简化对象的相互连接，它们仅仅需要保持一个指向其后继者的引用，而不需要保持所有候选接收者的引用。
__需要事先设置后继者。__

可以在客户端设置责任链的上游，这样可以很好的解决原来大量的分支判断造成难维护、灵活性差的问题

# 25.中介者模式（调停者模式，Mediator）
通过中介者，可以将系统的 **网状结构** 变成一个以中介者为中心的 **星状结构。**

> **概念：** 用一个中介对象来封装一系列的对象的交互。中介者使各对象不需要显式的相互作用，从而使其耦合松散，而且可以独立的改变它们之间的交互。

**中介者模式的优点：**
- Mediator的出现减少了各个Colleague的耦合，使得可以独立的改变和复用各个Colleague类和Mediator类
- 将对象如何协作进行抽象，把Mediator作为一个独立的概念并将其封装在一个对象中，关注的对象变为它们之间的交互中，站在更宏观的角度看待系统。

**中介者模式缺点：**
- 交互复杂性 --》 中介者复杂性
中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多子类的场合。

# 26.享元模式（Flyweight）
运用共享技术有效的支持大量细粒度（Flyweight轻量级）的对象。
```csharp
abstract class Flyweight //享元类抽象接口
{
    public abstract void Operation (int extrinsicstate);
}

class ConcreteFlyweight : Flyweight //实现flyweight接口，增加存储空间
{
    public override void Operation (int extrinsicstate)
    {
        Console.WriteLine("具体Flyweight：" +extrinsicstate);
    }
}

class UnsharedConcreteFlyweight : Flyweight //不需要共享的flyweight子类
{
    public override void Operation (int extrinsicstate)
    {
        Console.WriteLine("不共享的具体Flyweight：" +extrinsicstate);
    }
}

Class FlyweightFactory //享元工厂，用来创建并管理flyweight对象
{
    private Hashtable flyweights = new Hashtable();
    public FlyweightFactory()
    {
        flyweights.Add("X",new ConcreteFlyweight());
        flyweights.Add("Y",new ConcreteFlyweight());
        flyweights.Add("Z",new ConcreteFlyweight());
    }
    public Flyweight GetFlyweight(string key)
    {
        return ((Flyweight)flyweights[key]);
    }
}

```
享元模式可以避免大量非常 **相似类** 的开销。该模式运用共享技术有效地支持大量细粒度的对象。

__应用场景：__
1. 如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销；
2. 对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组的对象，此时就可以考虑使用享元模式。
比如string对象使用了享元模式。

# 27.解释器模式(interpreter)
> 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**需要解决的问题：** 如果一个特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

当有一个语言需要解释执行的时候，并且你可将该语言中的句子表示为一个抽象的语法树，此时就可以使用解释器模式。

典型的应用有：正则表达式、浏览器解析HTML文件
```csharp
abstract class AbstractExpression//抽象表达式，这个接口为抽象语法树中的所有节点所共享
{
    public abstract void Interpret(Context context);
}

class TerminalExpression: AbstractExpression//终结符表达式，实现与文法中的终结符相关联的解释操作
{
    public override void Interpret(Context context)
    {
        Console.WriteLine("终端解释器");
    }
}

class NonterminalExpression: AbstractExpression//非终结表达式，为文法中的非终结符实现解释操作，文法中的每一条规则R1、R2.。。。Rn都需要一个具体的非终结表达式类
{
    public override void Interpret(Context context)
    {
        Console.WriteLine("非终端解释器");
    }
}

class Context//Context,包含解释器之外的一些全局信息
{
    private string input;
    public string Input
    {
        get{return input;}
        set{input = value;}
    }
    private string output;
    public string Output
    {
        get{return output;}
        set{output = value;}
    }
}

```
# 28.访问者模式(Visitor)
> 访问者模式讲的是表示一个作用于某对象结构中各个元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
> 笑话一则：男人与女人最大的区别就是，比上不足，比下有余。

充分使用了 **双分派** 的技术，实现处理和数据结构分离。
- visitor指的是两者都根据某种共有的状态进行的不同的反应，而这个visitor正好是提供了表示这种反应的统一接口，封装了不同的反应。
- ObjectStructure是封装的两种或多种对象，这也是对象的稳定的结构。

访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由地演化。
访问者模式的目的是要把 **处理从数据结构** 中分离出来。
访问者模式的优点是增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式讲有关行为集中到一个访问者对象中。
访问者模式的缺点是增加新的数据结构更困难了，也相对比较复杂。
大多数情况并不需要访问者模式，很难找到数据结构不变化的情况。

# 29.各种模式的总结
将24个设计模式可以大体分为三个类别：
- 创建型模式（6个）
- 简单工厂
- 抽象工厂
- 建造者模式
- 工厂方法模式
- 原型模式
- 单例模式

创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。
创建者模式都会将关于该系统使用哪些具体的类的信息封装起来，允许客户用结构和功能差别很大的‘产品’对象配置一个系统。

- 结构型模式（7个）
- 适配器模式
- 桥接模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

找出变化，并将变化封装。

- 行为型模式（11个）
- 观察者模式
- 模板方法模式
- 命令模式
- 状态模式
- 职责链模式
- 解释器模式
- 中介模式
- 访问者模式
- 策略模式
- 备忘录模式
- 迭代器模式

面向对象设计模式体现的就是 **抽象** 的思想，*类是对象的抽象，抽象类是类的抽象，接口是对行为的抽象。*
