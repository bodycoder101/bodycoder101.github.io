<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[新环境下Hexo博客部署及维护]]></title>
      <url>http://bodycoder101.github.io/2017/02/20/%E6%96%B0%E7%8E%AF%E5%A2%83%E4%B8%8BHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%BB%B4%E6%8A%A4/</url>
      <content type="html"><![CDATA[<p>   之前的博客源码一直放在Linux（CentOS）环境下，最近想要更新博客，发现在Linux环境下编辑Markdown文件各种不方便；在Windows环境写好后再传到Linux环境下再部署总觉得多此一举，遂想要将博客迁移出来，期间遇到了各种问题，还好都解决了。将出现的问题及解决方法总结记录下来，以后或许还能用上。<br>   <a id="more"></a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>之前博主已经将博客源码推送至github中，和多数人一样，是一个仓库做两个分支：</p>
<ul>
<li>master分支：存放博客部署的静态文件(也就是public文件夹下的内容)</li>
<li>hexo分支：存放博客源文件，配置文件等</li>
</ul>
<p>在新环境(Windows)下安装配置<em>Git，Node.js，Python</em>;Python建议下载2.7版本，安装好后别忘了配置环境变量。<br>提供下载链接：</p>
<ul>
<li><a href="https://github.com/waylau/git-for-win" target="_blank" rel="external">Git</a></li>
<li><a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js</a></li>
<li><a href="https://www.python.org/downloads/" target="_blank" rel="external">Python</a></li>
</ul>
<h2 id="新环境部署"><a href="#新环境部署" class="headerlink" title="新环境部署"></a>新环境部署</h2><p>首先在我们新环境下为我们的博客新建一个目录blog。在该目录下右键执行<strong>Git Bash Here,</strong>然后克隆你的远程仓库，也就是hexo分支上的内容；<br><code>git clone https://github.com/bodycoder101/bodycoder101.github.io.git newBlog</code></p>
<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>出现clone失败报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub.IO.ProcessException: fatal: unable to stat &apos;plugins/toolongname/example/app/platforms/toolongname/toolongname/build/intermediates/classes/debug/org/toolongname/toolongname/toolongname$toolongname$toolongname.class&apos;: Filename too long</span><br></pre></td></tr></table></figure></p>
<p>后面各种找解决方法，终于找到一个靠谱的方案: <a href="http://ourcodeworld.com/articles/read/109/how-to-solve-filename-too-long-error-in-git-powershell-and-github-application-for-windows" target="_blank" rel="external">Solution</a>，原因也解释的很清楚；<br>在Bash中键入命令:<code>git config --system core.longpaths true</code>; 问题解决。</p>
<h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>进入博客根目录：<code>cd newBlog</code>；然后依次键入下列命令<strong>[1]</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo -server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>出现各种问题，无法安装<em>hexo</em>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm ERR! System Windows_NT 6.1.7601</span><br><span class="line">npm ERR! command &quot;c:\\Program Files\\nodejs\\node.exe&quot; &quot;c:\\Program Files\\nodej</span><br><span class="line">s\\node_modules\\npm\\bin\\npm-cli.js&quot; &quot;install&quot;</span><br><span class="line">npm ERR! cwd f:\Workspace\Angular_workspace\angular-phonecat</span><br><span class="line">npm ERR! node -v v0.10.28</span><br><span class="line">npm ERR! npm -v 1.4.9</span><br><span class="line">npm ERR! path C:\Users\Shivam\AppData\Roaming\npm-cache\inherits\2.0.1\package</span><br><span class="line">npm ERR! code EPERM</span><br><span class="line">npm ERR! errno 50</span><br><span class="line">npm ERR! stack Error: EPERM, unlink &apos;C:\Users\Shivam\AppData\Roaming\npm-cache\i</span><br><span class="line">nherits\2.0.1\package&apos;</span><br><span class="line">npm http 200 https://registry.npmjs.org/qs</span><br></pre></td></tr></table></figure></p>
<p>找到解决方案，依次键入下列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br><span class="line">npm cache clean</span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure></p>
<p>问题完美的解决，然后重新执行[1]处命令，就在博主认为可以愉快的写博客的时候，问题又出现了；</p>
<h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><p>执行<code>hexo clean</code>,出现下列问题：<br><img src="https://raw.githubusercontent.com/bodycoder101/MarkdownPhotos/master/hexo_clean_error.png" alt=""><br>根据提示键入命令安装：<br><code>npm rebuild node-sass</code><br>安装过程出现各种<code>npm error，gyp error</code>，在查找问题过程中，出错信息提示：<br><img src="https://raw.githubusercontent.com/bodycoder101/MarkdownPhotos/master/could_not_find_python.png" alt=""></p>
<p>那就新环境下安装<strong>Python！</strong>，忘安装了..<br>至此，问题全部解决，可以愉快的写博客了！</p>
<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>1.<a href="http://www.lzblog.cn/2016/11/21/Hexo%E5%8D%9A%E5%AE%A2%E5%A4%9A%E7%94%B5%E8%84%91%E5%90%8C%E6%AD%A5%E5%8F%8A%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">Hexo博客多电脑同步及更换电脑后处理方式</a><br>2.<a href="http://www.rvclient.com/2016/05/21/hexo-everywhere/" target="_blank" rel="external">在不同的电脑维护Hexo和写作</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA的学习之第五章]]></title>
      <url>http://bodycoder101.github.io/2017/02/17/JAVA%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p>本章主要是讲述OOP中的<strong>继承（inheritance）</strong>，利用继承，人们可以基于已存在的类构造一个新类，继承已存在的类也就是复用这些类的方法和域。<br><a id="more"></a></p>
<h2 id="一、类、超类和子类"><a href="#一、类、超类和子类" class="headerlink" title="一、类、超类和子类"></a>一、类、超类和子类</h2><p>继承的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Manager extends Employee//Java 用关键字extends代替C++中的冒号：，Java中所有的继承都是公有继承，没有私有继承和保护继承</span><br><span class="line">&#123;</span><br><span class="line">//add new files and methods</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Employee称为超类（superclass），基类（base class）或父类（parent class）；Maanager称为子类（subclass）、派生类（derived class）或孩子类（child class）。</span><br></pre></td></tr></table></figure></p>
<h3 id="1-易错点："><a href="#1-易错点：" class="headerlink" title="1. 易错点："></a>1. 易错点：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Manager boss=new Manger(...);</span><br><span class="line">Employee[] staff=new Employee[3];</span><br><span class="line">staff[0]=boss;</span><br><span class="line"></span><br><span class="line">boss.setBonus(5000);//OK</span><br><span class="line">staff[0].setBonus(5000);//EROR</span><br><span class="line"></span><br><span class="line">Manager m=staff[i];//EROR</span><br><span class="line">Employee[] staff=managers;//OK</span><br><span class="line">Manager boss=(Manager) staff[0];//ok</span><br></pre></td></tr></table></figure>
<p>上个例子中，变量staff[0]与boss引用同一个对象，编译器将staff[0]看成Employee对象，故语句6错误；<br>语句8错误的原因，并不是所有的雇员都是经理，小不能赋值给大；<br>语句9正确的原因，所有的经理都是雇员，大（子类，大指的是域值大）可以赋值给小（父类）；<br>总结：<strong>只能大赋小</strong><br>语句10正确的原因，父类赋值给子类必须进行强制类型转换，编译通过（本身staff[0]就是存储Manager类对象，只不过staff是Employee类的对象数组）</p>
<p><strong>注意</strong>：在将父类转换为之类之前，应该使用<strong>instanceof</strong>进行检查。</p>
<h2 id="二、JAVA中-Object类是所有类的超类"><a href="#二、JAVA中-Object类是所有类的超类" class="headerlink" title="二、JAVA中 Object类是所有类的超类"></a>二、JAVA中 Object类是所有类的超类</h2><h3 id="1-有关散列hasCode的问题："><a href="#1-有关散列hasCode的问题：" class="headerlink" title="1.有关散列hasCode的问题："></a>1.有关散列hasCode的问题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s=&quot;OK&quot;;</span><br><span class="line">StringBuilder sb=new StringBuilder(s);</span><br><span class="line">System.out.println(s.hashCode()+&quot; &quot;+sb.hasCode());</span><br><span class="line">String t=new String(&quot;OK&quot;);</span><br><span class="line">StringBuilder tb=new StringBuilder(t);</span><br><span class="line">System.out.println(t.hashCode()+&quot;&quot;+tb.hasCode());</span><br></pre></td></tr></table></figure>
<p>打印出来可知，字符串s和t拥有相同的散列码，<strong>字符串的散列码是由内容导出的，所以字符串的散列码相等，字符串缓冲sb与tb有着不同的散列码，散列码是该对象的存储地址，可以看到不相等</strong></p>
<h3 id="2-toString方法"><a href="#2-toString方法" class="headerlink" title="2.toString方法"></a>2.toString方法</h3><p>绝大多数的toString方法，遵循以下格式：<br>类的名字，随后是一对方括号起来的域值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String toString()</span><br><span class="line">&#123;</span><br><span class="line">return getClass().getName()+&quot;[name=&quot;+name+&quot;,salary=&quot;+salary+&quot;,hireDay&quot;+hireDay+&quot;]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要对象与一个字符串通过操作符<strong>“+”</strong>连接起来，Java编译就会自动地调用toString方法，获得对象的字符串描述；</p>
<h3 id="3-泛型数组列表"><a href="#3-泛型数组列表" class="headerlink" title="3.泛型数组列表"></a>3.泛型数组列表</h3><p>主要是实现动态数组<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Employee&gt; staff=new ArrayList&lt;&gt;(填写初始容量);//在添加或删除元素时，具有自动调节数组容量的功能；</span><br></pre></td></tr></table></figure></p>
<p> ArrayList是一个采用类型参数的范类型</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JAVA的学习之第四章]]></title>
      <url>http://bodycoder101.github.io/2017/02/16/JAVA%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p>1.对实例域做出修改的方法称为<strong>更改器</strong>方法，仅仅访问实例域而不进行修改的方法称为<strong>访问器</strong>方法；</p>
<p>2.在一个源文件中，只能有一个公共类，但可以有任意数目的非公共类；</p>
<p>3.数据成员也就是实例域，建议都是使用private修饰，确保封装性；</p>
<a id="more"></a>
<p>4.私有的方法（private）不会被外部的其他类操作调用，可以将其删去，如果方法是公有的（public）就不能将其删去，因为其他代码可能依赖它；</p>
<p>5.修饰符中的final以及static的区别和联系？<br>static表示不要实例化就可以使用，修饰的变量或者方法被所有实例共享；<br>final表示不可改变，终态，可以理解为常量，一旦在类中定义并且初始化，就不可改变；</p>
<p>6.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Employee</span><br><span class="line">&#123;</span><br><span class="line"> private static int nextId=1;//该类的所有事例将共享一个nextID，也就是说只有一个</span><br><span class="line"> private int id;//所有实例（对象）均有各自的拷贝</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 7.静态方法不能操作对象，不能在静态方法中访问实例域，只能访问自身类中的静态域；可以通过类名直接调用静态方法；由static修饰的变量或者函数，表示属于类且不属于类对象的变量和函数；</p>
<p> 8.类中的静态main方法，用于测试类<br> 二，值调用和引用调用，Java对对像采用的是值专递；总结：</p>
<ul>
<li>一个方法不能修改一个基本的数据类型的参数（数值型和布尔型）</li>
<li>一个方法可以改变一个对象参数的状态；</li>
<li>一个方法不能让对象参数引用一个新的对象；</li>
</ul>
<p>9.如果构造器中没有显式的给域赋予初值，那么就会被自动的赋予默认值：数值为0、布尔值为false，对象引用为null；</p>
<p>10，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">publi Employee(String name,doble salary)//类的构造器</span><br><span class="line">&#123;</span><br><span class="line">this.name=name;//this指示隐式参数，也就是实际的实例值，参数变量用相同的名字将实例域屏蔽起来</span><br><span class="line">this.salary=salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>11，Java使用包（package）的主要原因是确保类名的唯一性，相当于C++中的命名空间（namespace），一个源文件中只能包含一个公共类（public static void main(){}）</p>
<ul>
<li>列表项</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Window extends Container</span><br><span class="line">&#123;</span><br><span class="line"> String warningString;//没有指定访问修饰符public 和 private，这里的变量默认不是private，意味着java.awt包中所有的类的方法都可以访问该变量！</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用hexo搭建个人博客[转]]]></title>
      <url>http://bodycoder101.github.io/2016/06/05/%E8%BD%AC-%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>从很久之前就想要有一个属于自己的博客，如果互联网是一个世界的话，一个有着自己独特域名的博客应该就是在这个世界里面的自己的家吧。由于毕业后工作，后来又忙着考研，这个简单的愿望一直搁浅。<br>现在趁着有闲暇的精力，终于把这个一拖再拖的事情给实现，搭建过程总体是简单的，没有费多少力气，但是还是遇到了一些小问题，现在将遇到的问题记录下来。<br><a id="more"></a></p>
<h3 id="关于博客源码的备份和同步更新"><a href="#关于博客源码的备份和同步更新" class="headerlink" title="关于博客源码的备份和同步更新"></a>关于博客源码的备份和同步更新</h3><h4 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h4><p>这个让我费时不少，因为考虑到有时候在自己笔记本上更新博客，有时候在实验室电脑上更新，这个时候问题就出现了。其一，不可能每次带U盘copy，其二，如果用百度云或者Dropbox这类云盘，感觉总是有些麻烦的。<br>所以还是考虑用github 存放源码，但是有遇到两个选择：</p>
<ul>
<li>一种方案是重新开一个repo，这样一个repo放博客生成的静态文件，另外一个repo专门放博客源码。</li>
<li>另外一种方案是一个repo开两个分支，其中一个master分支主要放静态文件，另外一个分支（自己命名）hexo，专门放博客源码。</li>
</ul>
<p>第一种方案总感觉冗余，而第二种看起来更加简洁干净（操作起来也遇到了不少麻烦），最终还是选择第二种方案。</p>
<h4 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h4><ul>
<li>问题描述</li>
</ul>
<p>因为我是先在本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init 、git add origin &lt;server&gt;</span><br></pre></td></tr></table></figure></p>
<p>初始化本地文件夹，然后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;description&quot;</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></p>
<p>最后一步失败。尝试过git pull命令、并将hexo分支文件清空，然而都无济于事。</p>
<ul>
<li>解决问题：</li>
</ul>
<p>删掉这个库zouzls.github.io,然后重新新建，开两个分支，并设置hexo默认分支，此时两个分支为空。<br>在本地新建一个文件夹，git clone server地址,然后copy原来的博客站文件过来当前文件夹，运行下列命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;description&quot;</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
<p>然后解决问题，博客源码推送到hexo分支，再在新的电脑将源码clone下来就OK了，前提是已经安装有git、nodejs、hexo。至于由博客生成的静态html文件如何放到master分支，网上太多教程就不详述了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>人生有涯，知也无涯。<br>坚持学习，保持好奇心。<br>坚持锻炼身体。<br>转载来自：<a href="http://zouzls.github.io/" target="_blank" rel="external">http://zouzls.github.io/</a></p>
]]></content>
    </entry>
    
  
  
</search>
